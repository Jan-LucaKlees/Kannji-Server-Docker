# the version of the docker-compose file
version: '2.1'

# list of services - meaning containers - to be managed by docker-compose
services:

  # the api-db container
  api-db:

    # this tells docker-compose to build an image using the Dockerfile found at the path specified by the context attribute.
    build:
      context: ./api-db/

    # this will be the name of the image, once it's built
    image: kannji_api-db

    # environment variables which will be accessible in the running container
    # the values of ${API_DB_USER}, ${API_DB_PASSWORD}, ${API_DB_DBNAME} come from the .env file lying in the same dir as this file
    environment:
      - POSTGRES_USER=${API_DB_USER}
      - POSTGRES_PASSWORD=${API_DB_PASSWORD}
      - POSTGRES_DB=${API_DB_DBNAME}

    # this defines how this container will be rated as "healthy"
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 10s
      retries: 15

    # which networks is the container connected to
    networks:
      - api

    # volumes to be mounted from the host into the container (host-path:container-path)
    volumes:
      - ./api-db/data/:/var/lib/postgresql/data/

  # the api-server
  api-server:

    # build the api-server with the Dockerfile found at context
    build:
      context: ./api-server/

    # name its this
    image: kannji_api-server

    # these are the environment variables which will be accessible in the running container
    # their values come from the .env file located in the same folder as this one.
    environment:
      - API_DB_USER
      - API_DB_PASSWORD
      - API_DB_DBNAME
      - API_SERVER_SECRET_KEY

    # which container need to be in what condition for this container to be able to run?
    depends_on:
      # the status of the api-db needs to be healthy (see above)
      api-db:
        condition: service_healthy

    # the api-server needs to handle incoming requests, so it is connected to the nginx- (for incoming requests) and the api-db-network (for accessing the database)
    # note: added security as there is no direct access to the db from outside the host.
    networks:
      - api
      - nginx

  # the nginx server
  nginx:

    # build it by using the DOcker file at context
    build:
      context: ./nginx/

    # give it this name
    image: kannji_nginx

    # the nginx needs to handle requests from outside the host, so we add these port-mappings.
    # on the host all incoming requests to the port 80 will be forwarded to the containers 80 port.
    # same with the 443 port (https)
    # sceme: <port on container:port on host>
    # example: "8000:80" will map all requests to the host on port 80 to the container on port 8000
    ports:
      - "80:80"
      - "443:443"

    # to be able pass requests to other containers the nginx has an own network.
    # all accessible containers must be in this network.
    networks:
      - nginx

    # as nginx checks if hostnames in the config file are accessible, the nginx can only start, when the api-server is running.
    # technically we would need a health-check, but the api-server starts so fast, that it's not necessary
    depends_on:
      - api-server

# here we specify which networks should be created
# only networks that are written down here can be referenced in the services. (exception being the 'default' network, which we don't use due to it's meaningless name)
networks:
  # we don't want any fancy config for our networks, so only the name suffices
  api:
  nginx: